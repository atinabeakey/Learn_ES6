# atinaES6
There are some examples of ES6

***
## atinaES6 - Chapter.01 - 变量声明关键字 2017.09.08
---
> **1. ES6 关键字 _`let`_**
> > 块级作用域
> > > `if` & 无变量提升  
> > > `for` & 变量泄漏  
> > 暂存死区TDZ ( 函数默认值等不明显的TDZ,TDZ作用就是在`let/const`的使用上 )
> > 变量名唯一，不允许重复声明
> > 变量归属 ( 以及 `eval()` )

> **2. ES6 关键字 _`const`_**
> > 常量
> > > 声明的同时必须进行初始化  
> > > 非对象数据类型一经赋值，无法被更改  
> > > 针对对象只锁定地址的特殊处理办法 ( `Object.freeze()` & 递归深冻结 )  
> > 拥有所有 `let` 关键字的特点

> **ES5 关键字 _`var`_ 与 _`let`_ 对比**
***
## atinaES6 - Chapter.02 - 解构赋值 2017.09.15
***
解构赋值 语法是一个Javascript表达式，这使得可以将值从数组或属性从对象提取到不同的变量中
---
> **1. 数组的解构赋值**
> > 结构一致，位置对应  
> > 解构失败：模式数组位数 > 字面量数组位数  
> > 不完全解构：模式数组位数 < 字面量数组位数  

> **2. 默认值**
> > 字面量数组对应位的字面量严格等于`undefined`(惰性)  
> > 默认值可以引用模式数组中的其他变量，但被引用变量必须提前声明

> **3. 对象的解构赋值**
> > 结构一致，与位置无关，键名对应  
> > 简化键值对写法  
> > 声明的变量名与对象字面量中的key不同的解构，需要通过相同模式key来转换

> **4. 圆括号的使用问题**
> > 模式*对象*中的key值必须未被进行 `let` | `const` 声明，否则应使用 `()` 来解析

> **5. 字符串的解构赋值**
> > 以数组形式解构  
> > 以对象形式解构(包装对象)  

> **6. 函数参数的解构赋值**
> > 模式数组参数  
> > 模式对象参数( 默认值的两种形式 )  

> **7. 展开运算符...**
> > 数组可以直接展开，对象不行  
> > 应用：替代 `Function.prototype.apply` ， `[]` 以及 `{}` 自由组合，  
> > 和...rest参数的区别

> **8. 应用**
> > 数组：交换值，函数返回值解构  
> > 对象：提取JSON数据，函数解构传参，函数返回值解构  
> > 函数参数默认值：ajax方法
***
## atinaES6 - Chapter.03 - 字符串扩展
---
